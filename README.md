# INT-18-Лавренов_Дмитрий

## 1) Максимально точная сумма массива чисел с плавающей точкой

Задание находится в директории `float_calculator`.

Для запуска использовать `go run main.go file_name.txt`

Вывод будет в виде значений `Compensated Sum` и `Naive Sum`, вывод алгоритма с повышенной точностью и обычная сумма для
сравнения.

Максимально точная сумма вычисляется в функции `CompensatedSum`.  
Вычисления происходят с помощью алгоритма Кэхэна (компенсационного суммирования) в который были добавлены улучшения.
Сам алгоритм заключается в вычислении ошибки округления, которая появляется при сложениях очень больших и очень маленьких
чисел и при сложении чисел, которые не имеют точное двоичное представление, и учитывает её, вычитая это значение
из суммы.
Плюс к этому было добавлено 2 улучшения:
- Использование `big.Float` вместо `float64`. Хоть они и хранятся в памяти по разному, но в обоих случаях числа хранятся
в формате: знак, мантиса и порядок, но в `big.Float` к этому добавляется точность мантисы (определяет количество
значащих битов, используемых для мантиссы), в `float64` всегда используется 52 бита для мантиссы.
Использование `big.Float` помогает не терять значащие биты (в контексте `big.Float` слово "биты" условно, так как мантиса
и экспонента хранятся в формате `big.Int`) при работе с очень большими и очень маленькими значениями,
следовательно, увеличить точность вычислений.
- Сортировка значений по модулю перед их суммированием. По модулю она из-за того, что, например, между этими  числами
0.5 и -0.5 разница только в значении знака, а мантиса и экспонента одинаковы. 
Это помогает избежать больших ошибок округления, чтобы числа с большими значениями не складывались с очень маленькими
значениями.

Точнее можно было бы сделать, если разделять числа на целую и дробную часть и работать с целыми числами, но я решил
оставаться в арифметике с числами с плавающей точкой.


## 2) Вычисления и лимитирование числа запросов

Задание находится в директории `calculation_service`.

Также в `test/calculation_service_unit_test` находятся юнит-тесты.

### Запуск

Для запуска использовать в этой директории `docker compose up` 

Чтобы изменить параметры запуска, нужно изменить файл `.env` в `calculation_service` (он уже есть в архиве).
Он имеет вид:
```
CALCULATION_PORT=8080
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_DATABASE=0
REDIS_SYNC_INTERVAL=250ms
REDIS_TTL=2s
INTERVAL=1s
LIMIT=5
SYNC_WINDOW_KEY=window
```

Где:
- `CALCULATION_PORT` - порт на котором запустится сервис
- `REDIS_HOST` - хост Redis (в данном контексте имя контейнера из docker-compose.yml)
- `REDIS_PORT` - порт на котором будет запущен Redis
- `REDIS_DATABASE` - индекс базы данных в Redis
- `REDIS_SYNC_INTERVAL` - интервал с которым приложение будет синхронизироваться с Redis. При большом лимите запросов
на промежуток времени, желательно уменьшать этот интервал для большей точности лимитирования запросов, но это увеличит
нагрузку на бд
- `REDIS_TTL` - ttl окна в Redis, указывать как минимум вдвое больше, чем `INTERVAL`
- `INTERVAL` - интервал времени, на который мы вводим лимитирование
- `LIMIT` - количество разрешенных запросов за указанный интервал
- `SYNC_WINDOW_KEY` - имя окна (нужно для того, чтобы его могли использовать несколько сервисов)


### Сервис принимает POST запросы с json

Пояснения к переменным:
```json
{
  "values": [X1, X2, X3, Y1, Y2, Y3],
  "e": 1
}
```

В итоговом виде он выглядит так:

```json
{
  "values": [1.0, 2.0, 3.0, 1.0, 2.0, 3.0],
  "e": 1
}
```

Пример запроса:
```shell
curl -X POST http://localhost:8080   -H 'Content-Type: application/json'   -d '{
    "values": [1, 2.12345, 3, 1, 2, 3],
    "e": 1
  }'
```

И ответа:
```json
{"x":1.4,"y":1.5,"is_equal":"F"}
```

### Пояснение к решению

Для реализации http использовалась библиотека `github.com/valyala/fasthttp`. Выбрана она из-за того, что является более
быстрой альтернативой `net/http`, благодаря минимизации аллокаций памяти, эффективной работе с сетевыми соединениями
и использованию более низкоуровневых API.

Для установки лимита на число запросов использовалась библиотека `github.com/RussellLuo/slidingwindow`, которая
предоставляет метод скользящего окна. Использовал его, так как этот метод лучше подходит под условие жесткого
ограничения на количество запросов в заданный интервал времени, так же эта библиотека предоставляет удобные интерфейсы
для синхронизированного окна. 

Redis тут используется для хранения состояния окна в формате:
- ключ: имя окна + время старта окна
- значение: количество запросов, произошедших в этом окне

Это позволяет нам управлять лимитированием нагрузки не только в одном сервисе, например, использовать одно окно для
всего приложения или же использовать несколько разных окон, каждое из которых будет отведено группе сервисов.

Из проблем такого решения только то, что нужно выбирать между точностью лимитирования и нагрузкой на сервер с Redis,
выставляя большие или меньшие интервалы синхронизации окна сервиса с окном в Redis.